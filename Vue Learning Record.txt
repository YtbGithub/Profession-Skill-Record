First Meet With Vue

//element web : https://element.eleme.cn/#/zh-CN

1.download & install
	download:https://cn.vuejs.org/(中文) OR https://vuejs.org/(英文)
	install: Development Vesion(开发版) OR Production Vesion(生产版)
	
	start...
	vue-cli：install it that need npm, so download node.js because of itself installed, and then setting config on npm.
		1.npm config set registry=http://registry.npm.taobao.org, 镜像源
		2.npm config set prefix "D:\nodejs\node_global", 设置全局仓库
		3.npm config set cache "D:\nodejs\node_cache", 设置缓存
		4.npm config list, 查看配置
		5.配置文件后缀.npmrc
		6.npm config get registry, 获取registry这个变量的值
		7.npm install package-name -g, 安装到全局
		8.npm list -global, 查看全局的包
		
	download:
		npm install npm -g
		npm isntall vue-cli -g
		
	installed vue-cli:
		配置vue文件所在的父目录到环境变量中，否则报错找不到vue
		
	vue-cli init project:
		1.切换到准备创建的目录下
		2.vue init webpack project_name
		3.cd project_name
		4.npm install
		5.npm[run dev/bulid] (给地址不打卡浏览器/打包服务)
		
	vue-cli open project:
		cd project_directories
		npm run built
	
	vue & python
		cd project_directories
		npm install --save axios, 前后通讯
		import axios from 'axios', 导入包
	ending...	
	
2.useful plug-in
	Vue Devtools to download in https://vuejs.org/ OR from github.com/vuejs/vue-devtools download to window/mac as .zip file
	May have another method:git clone https://github.com/vuejs/vue-devtools.git and than get in folder and you can use `cnpm install` to install it and then you can `npm run bulid` to verification for is it successful or not
	After my attempt, I failed.

3.Declarative Rendering
	3.1	声明示例
		var variable_name = new Vue({})
		new Vue({
			el:'element class or id',
			data(){
				return {
					key1:value1,
					key2:value2,
					...
				}
			},methods{
				function1_name(){},
				function2_name(){}
			},
			// 钩子可以使用this来做操作数据, 且所有钩子中不可使用箭头函数
			beforeCreate:function(){},	==> 实例创建之前调用
			created:function(){},		==> 实例创建之后调用, 通常在这里处理请求数据, 一般不会出现再次
			beforeMount:function(){},	==> 渲染之前调用
			mounted:function(){},		==> 渲染成功后调用, 与updated一样, 如果修改数据会再次走自己的函数体
			beforeUpdate:function(){},	==> 数据更改前调用, 每次数据修改会重走，所以千万不要与updated修改同一数据, 会死循环
			updated:function(){},		==> 数据更改后调用, 与mounted一样, 如果修改数据会再次走自己的函数体
			beforDestroy:function(){},	==> 销毁之前调用
			destroyed:function(){}		==> 销毁之后调用
		})
		3.1.1
			@click=function1_name():methods中方法使用
		
		3.1.2
			Object.freeze(obj):释放的对象Vue无法追踪其变化
		
		3.1.3
			obj.$watch('element tag in obj', function(newValue, oldValue){
				例如：obj=vm, element tag=a
				那么这个函数的功能为, vm.a改变后调用
			})
		
	3.2 模板语法
		3.2.1 插值
			文本：{{ rawHTML }}, 解释为文本
			HTML: v-html, 解释为HTML
			Attribute：v-bind,  格式 v-bind:[attributeName] = '', 即动态给url赋值, 给id赋值..., 例如v-bind:url="..."
			javascropt: {{ no ? 'yes':'no'}}
			
		3.2.2 指令
			参数	
				v-bind：响应式(更改后刷新, 得到新值加载到页面)地更新HTML attribute, 即更新属性
				v-on: 监听DOM(Document Object Model)事件,
			动态赋值：v-bind:[attributeName] = '', v-on:[eventName]='', 
				[动态参数赋值]: 期待str or null, else Invalid value for dynamic directive argument (expected string or null)
				[动态参数表达式拼接]: 拒绝spaces(' '), quotes(':'), <, >, / or =.
			修饰符：'.'
				example, .prevent 就是 e

4. 事件处理
	4.1 监听事件
		v-on: 监听DOM事件并触发时运行一些js代码
			不过有两个有趣的地方，第一个是在v-on的监听中可以直接控制某个变量，譬如<buttom v-on:click="counter+=1">...，
			当然一定是在某种情况下，就是该元素一定是在new Vue({})的el实例化；第二个就是直接绑定一个点击函数，
			有趣的是，该函数会被传入一个参数，就是event，官方解释是说event是原生DOM事件，而原生的DOM事件也就是javascript操作的
			window.createElement...，看过例子、了解了原生DOM还是不明白，我去打印一下什么是event
		
5.data from Vue to Python
	import axios from 'axios'
	axios.get('path').then(function(response){...}).catch(function(error){...});
	axios.get('path').then(response => {...}).catch(error => {...});
	axios.get('path', {params:{'a':1, 'b':2}}).then(response => {...}).catch(error => {...});
		参数在django的request.GET中
	axios.post('path', {'a':1, 'b':2}).then(response => {...}).catch(error => {...});
		参数在djangp的request.body中可以使用.decode('utf-8')来限制编码格式

9.create
	⭐ 新建数据可以提升的点不大，就是在插入成功后将插入的数据push到父级的总数据中，这样做也是渲染一条数据而不是一个页面重新加载
		代码：this.$parent.父级数据对象.push(插入成功的数据)
		其中'插入成功的数据'需要注意，最好从后端获取，
		原因是前端的数据都是一样的格式如果直接用用户输入的数据进行push可能导致前端push的数据不够全面。
		example:
			正常数据{
				id:123,
				name:'杨腾博',
				age:24,
				more_information:[194,186,...]
			}
			前端push{
				name:new_name
				age:new_age
			}
			后端查询后push{
				id:123,
				name:'杨腾博',
				age:24,
				more_information:[..., ..., ...] OR []
			}
			如果more_information作为外键表的话(修改时并没有修改到外键表)，可以知道此时数据并不全面，尽管没有数据但是连这个变量都没有，可能会导致意料外的错误
			而且正常开发的环境比实例更加复杂所以手动添加外键表的变量就变得异常困难
		
	
10.retrieve
	⭐ 在一个同类型的页面中，最好使用一条查询函数，即高级查询函数，这样提升代码可读性的同时也降低了耦合
	
11.update
	⭐ 在vue中父节点传递数据给子节点后，子节点修改或父节点修改其实都是在更改同一个数据
	⭐ 正确的做法：
		1.从父节点传递参数的地方加入代码,JSON.parse(JSON.stringify(this.newProData[index])),目的就是避免类似浅拷贝的现象
		2.然后在子节点中给v-model绑定传入的数据(v-model绑定后双向修改,即页面更改对象也实时更改)，再次更改就不会实时修改父级的元素内容
		3.同时将修改好的数据进行捕获，传递给后台，更新成功后将信息获取回来并且添加到父级数据中原来的位置,this.$set('父级数据对象', '修改处的索引', '修改处的数据')
		4.第3步的好处是，从后台获取数据保证了数据一致性，且前端重新渲染一条数据从而交互速度大幅提升，进而提升用户体验感
		
		
12.delete
		

	
Vue 组件
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	<el-dialog
		title="标题"				
		:visible.sync="chartsDialog"	=> 是否显示,this.$refs.ChartsDialog.chartsDialog = true => chartsDialog应该在data中有定义，他们如果不同名的话就不会打开想要的页面
		width="882px"					
		class="chartsBox"				
		:modal="false"
		@open="open"					=> 开启调用
		@close="handleClose"			=> 关闭调用(含点击关闭、点击其他地方关闭)
	>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	<el-pagination
        background
        :current-page="currentPage"
        layout="total, prev, pager, next"
        :total="total"
        :page-size="5"
        @current-change="handleCurrentChange"
	/>
	必须同时有total，page-size两个参数，否则会按照默认来分页默认参数可以查看element-ui官网的pagination
	
	关于数据在前端做分页
		坑1：做好分页后第一次打开页面不触发页码改变函数，所以内容是空的
		心得：
			分页条件，[(当前页码-1)*每页尺寸, 当前页码*每页尺寸)，左闭右开
			如果数据的长度<结束长度那么将结束长度更改为数据的长度
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	<el-cascader
		v-model="addProject.pro_area"
		ref="cascaderAddr"
		placeholder="请选择项目区划"
		:options="this.$parent.area_options"
		:disabled="isDisabled"
		:props="{value:'id'}"		->决定获得的value是哪一项, 如{"id":1, "item":2}需要拿id,:props="{value:'id'}";需要拿item,:props="{value:'item'}"
		@change="handleChange"		->一个参数, value, 就是↑所说的传入是谁就是谁
	/>
		回显：
			回显参数格式：[i1, i2, i3], 其中ix(x=1,2,3...)是options绑定的对象中,value的部分
		example：
			options = [{
				id=1,
				value=a,
				lable="展示"
			}]
			回显参数：['a']
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	<el-select v-model="addProject.pro_state" :disabled="isDisabled" placeholder="prompt(提示)">
		<el-option
		  v-for="item in this.$parent.state_options"
		  :key="item.id"		->要绑定一个值让vue来判断是否需要重新渲染，否则报错
		  :label="item.title"
		  :value="item.id"		->只捕获这个值进行传输，传递给v-model监听的变量
		/>
	</el-select>
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TIPS:
	1.CRUD
	------------------------------------------------------------------------------------------------------------------------------------------------
    	create: 插入成功后将新数据这一条读出来，渲染到页面																   
	------------------------------------------------------------------------------------------------------------------------------------------------
		retrieve:在一个同类型的页面中，最好使用一条查询函数，即高级查询函数，这样提升代码可读性的同时也降低了耦合		   
	------------------------------------------------------------------------------------------------------------------------------------------------
		update：深拷贝数据赋值给子组件并进行更改																		   
	------------------------------------------------------------------------------------------------------------------------------------------------
		delete: 传递id删除，将页面的数据也同时删除(一条)，提升效率														   
	------------------------------------------------------------------------------------------------------------------------------------------------
	2.INPUT
	------------------------------------------------------------------------------------------------------------------------------------------------
		$("input[name='radioName']").prop('checked', false); 将所有name为radioName的input框的属性checked更改为false，即未选中，同理true为选中
	------------------------------------------------------------------------------------------------------------------------------------------------
	3.INTERVAL
	------------------------------------------------------------------------------------------------------------------------------------------------
		this.timer = setInterval(this.queryParameter, 1000) 定时多次 => clearInterval(this.timer) 清除定时任务
	------------------------------------------------------------------------------------------------------------------------------------------------
		this.timer = setTimeout(this.queryParameter, 1000) 定时一次
	------------------------------------------------------------------------------------------------------------------------------------------------
	4.Passing Parameters
	------------------------------------------------------------------------------------------------------------------------------------------------
		this.$refs.组件名字.组件内的变量 = 赋值
	------------------------------------------------------------------------------------------------------------------------------------------------
	5.Build a dictionaries, arrays
	------------------------------------------------------------------------------------------------------------------------------------------------
		dictionaries:	type parameter = {} => 	parameter.parameter_name = parameter_value, 就可以添加进去了
	------------------------------------------------------------------------------------------------------------------------------------------------
		arrays		:	type array = [] 	=>	array.push('parameter_value')
	------------------------------------------------------------------------------------------------------------------------------------------------
	6.HTTP REQUEST
	------------------------------------------------------------------------------------------------------------------------------------------------
		GET1:	axios.get('path').then(function(response){...}).catch(function(error){...});
	------------------------------------------------------------------------------------------------------------------------------------------------
		GET2:	axios.get('path').then(response => {...}).catch(error => {...});
	------------------------------------------------------------------------------------------------------------------------------------------------
		GET3:	axios.get('path', {params:{'a':1, 'b':2}}).then(response => {...}).catch(error => {...}); get传递参数，在django的request.GET中	
	------------------------------------------------------------------------------------------------------------------------------------------------
		POST:	axios.post('path', {'a':1, 'b':2}).then(response => {...}).catch(error => {...});post,parameter in django's request.body,usually with .decode('utf-8') together use
	------------------------------------------------------------------------------------------------------------------------------------------------
	7.contrast
	------------------------------------------------------------------------------------------------------------------------------------------------
		contrast_variable = JSON.stringify(contrast_variable)
		actual_variable = JSON.stringify(actual_variable)
		contrast_variable === actual_variable => return true or false
	------------------------------------------------------------------------------------------------------------------------------------------------
	8.类型转换
	------------------------------------------------------------------------------------------------------------------------------------------------
		parseInt(param)
	------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------
	------------------------------------------------------------------------------------------------------------------------------------------------

ERROR
	************************************************************************************************************************************************
	'vue-cli-service' 不是内部或外部命令，也不是可运行的程序 : 没有node_modules，需要运行一下npm install，即可解决
	************************************************************************************************************************************************
	************************************************************************************************************************************************
	************************************************************************************************************************************************
	
