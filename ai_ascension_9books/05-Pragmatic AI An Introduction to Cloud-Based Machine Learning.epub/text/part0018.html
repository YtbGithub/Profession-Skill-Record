<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" xmlns:ns="http://www.w3.org/2001/10/synthesis" xml:lang="en-us" lang="en-us">
  <head>
    <title>7 Creating an Intelligent Slackbot on AWS</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<h2 class="h1" id="ch07"><span epub:type="pagebreak" id="page_133" class="calibre2"></span>7</h2>
<h2 class="h2a">Creating an Intelligent Slackbot on AWS</h2>
<p class="blockquote"><em class="calibre5">The man who can drive himself further once the effort gets painful is the man who will win.</em></p>
<p class="attribution">Roger Bannister</p>
<p class="noindent">It has long been a dream to create “artificial life.” One of the most common ways to accomplish this has been to create bots. Bots are increasingly becoming part of our everyday life, especially with the rise of Apple’s Siri and Amazon’s Alexa. In this chapter, the mysteries of how to create bots are revealed.</p>
<h3 id="ch07lev1" class="calibre12">Creating a Bot</h3>
<p class="noindent">To create a bot, use the Python Slack library (<a href="https://github.com/slackapi/python-slackclient" class="calibre7">https://github.com/slackapi/python-slackclient</a>). To do anything with Slack, a token first needs to be generated. Generally, a good idea for dealing with tokens like this is to export an environmental variable. I often do this inside of a virtualenv; that way, when it is sourced, I automatically have access to it. This is accomplished by “hacking” the virtualenv by editing the activate script.</p>
<p class="noindent">To edit the virtualenv with the Slack variable, it would look like this if you edit the activate script <code class="calibre11">in ~/.env/bin/activate</code>.</p>
<p class="noindent">Just for reference, there is a new Python official recommended env management tool  (<a href="https://github.com/pypa/pipenv" class="calibre7">https://github.com/pypa/pipenv</a>) on the market, if you want to cover the latest.</p>
<p class="pre">  _OLD_VIRTUAL_PATH="$PATH"                                                        <br class="calibre9"/>
  PATH="$VIRTUAL_ENV/bin:$PATH"                                                    <br class="calibre9"/>
  export PATH                                                                      <br class="calibre9"/>
  SLACK_API_TOKEN=&lt;Your Token Here&gt;                                                                  <br class="calibre9"/>
  export SLACK_API_TOKEN</p>
<p class="noindent"><span epub:type="pagebreak" id="page_134"></span>A good way to check whether the environmental variable is set is to use the <code class="calibre11">printenv</code> command on OS X or Linux. Next, to test sending a message, the following short script should work.</p>
<p class="codelink"><a id="p134pro01" href="part0036_split_000.html#p134pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">import os<br class="calibre9"/>
from slackclient import SlackClient<br class="calibre9"/>
<br class="calibre9"/>
slack_token = os.environ["SLACK_API_TOKEN"]<br class="calibre9"/>
sc = SlackClient(slack_token)<br class="calibre9"/>
<br class="calibre9"/>
sc.api_call(<br class="calibre9"/>
  "chat.postMessage",<br class="calibre9"/>
  channel="#general",<br class="calibre9"/>
  text="Hello from my bot! :tada:"<br class="calibre9"/>
)</p>
<p class="noindent">It is also worth noting that pipenv is a recommended solution that can combine both pip and virtualenv as one component. In addition, it has become a new standard, so it is also worth exploring for package management.</p>
<h3 id="ch07lev2" class="calibre12">Converting the Library into a Command-Line Tool</h3>
<p class="noindent">Often, as in other examples in this book, it is a great idea to convert this code into a command-line utility so it is easy to iterate on ideas. It is worth pointing out that many new developers are often opposed to command-line tools in lieu of other solutions like simply working in Jupyter Notebook. To play devil’s advocate for a second, a question might come from a reader such as, “Why do we want to introduce command-line tools to a Jupyter Notebook–based project? Isn’t the point of Jupyter Notebook to eliminate the need to use the shell and command-line?” The nice thing about adding a command-line tool to your project, however, is it gives you the ability to quickly iterate on concepts with “alternative inputs.” Jupyter Notebook code blocks don’t take input, so in a sense they are hard-coded scripts.  </p>
<p class="noindent">There is a reason why both GCP and AWS have extensive command-line tools throughout their platforms: they add flexibility and power that GUIs just cannot match. A great essay on the subject written by the science fiction author Neal Stephenson is called, “In the Beginning…Was the Command Line.” In it, Stephenson states, “GUIs tend to impose a large overhead on every single piece of software, even the smallest, and this overhead completely changes the programming environment.” He finishes the essay with the statement, “[L]ife is a very hard and complicated thing; that no interface can change that; that anyone who believes otherwise is a sucker…” Pretty harsh, but in my experience it’s true. Life is better with the command-line. If you give it a try, you won’t look back.</p>
<p class="noindent">To accomplish this, the click framework is used, as shown, and the new interface makes it straightforward to send new messages.</p>
<p class="codelink"><a id="p134pro02" href="part0036_split_001.html#p134pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">./clibot.py send --message "from cli"<br class="calibre9"/>
sending message from cli to #general</p>
<p class="noindent"><a href="part0018.html#ch7fig1" class="calibre7">Figure 7.1</a> shows the default value set and a customized message from the <code class="calibre11">cli</code> utility.</p>
<p class="codelink"><a id="p135pro01" href="part0036_split_002.html#p135pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">#!/usr/bin/env python<br class="calibre9"/>
import os<br class="calibre9"/>
import click<br class="calibre9"/>
from slackclient import SlackClient<br class="calibre9"/>
<br class="calibre9"/>
SLACK_TOKEN = os.environ["SLACK_API_TOKEN"]<br class="calibre9"/>
<br class="calibre9"/>
def send_message(channel="#general",<br class="calibre9"/>
                 message="Hello from my bot!"):<br class="calibre9"/>
    """Send a message to a channel"""<br class="calibre9"/>
<br class="calibre9"/>
    slack_client = SlackClient(SLACK_TOKEN)<br class="calibre9"/>
    res = slack_client.api_call(<br class="calibre9"/>
      "chat.postMessage",<br class="calibre9"/>
      channel=channel,<br class="calibre9"/>
      text=message<br class="calibre9"/>
    )<br class="calibre9"/>
    return res<br class="calibre9"/>
<br class="calibre9"/>
@click.group()<br class="calibre9"/>
@click.version_option("0.1")<br class="calibre9"/>
def cli():<br class="calibre9"/>
    """<br class="calibre9"/>
    Command line utility for slackbots<br class="calibre9"/>
    """<br class="calibre9"/>
<br class="calibre9"/>
@cli.command("send")<br class="calibre9"/>
@click.option("--message", default="Hello from my bot!",<br class="calibre9"/>
                help="text of message")<br class="calibre9"/>
@click.option("--channel", default="#general",<br class="calibre9"/>
                help="general channel")<br class="calibre9"/>
def send(channel, message):<br class="calibre9"/>
    click.echo(f"sending message {message} to {channel}")<br class="calibre9"/>
    send_message(channel, message=message)<br class="calibre9"/>
<br class="calibre9"/>
if __name__ == '__main__':<br class="calibre9"/>
    cli()</p>
<div class="figure">
<div class="image"><span epub:type="pagebreak" id="page_135"></span><a id="ch7fig1" class="calibre7"></a><img src="../images/00040.jpeg" aria-describedby="alt_07fig01" alt="A screenshot of the Slackbot Command-Line Tool is shown." class="calibre8"/>
<aside class="hidden" id="alt_07fig01" data-AmznRemoved-M8="true" data-AmznRemoved="mobi7">
<p class="calibre21">The screen, Today displays Slack API Tester. A message below reads, Hello from my bot! A new message line below reads, from Cli. An add message (hashtag) general textbox is shown below with two options toward the right: at the rate of and a smiley.</p>
</aside>
</div>
<p class="fig_caption"><span class="calibre6">Figure 7.1</span> Slackbot Command-Line Tool</p>
</div>
<h3 id="ch07lev3" class="calibre12"><span epub:type="pagebreak" id="page_136" class="calibre2"></span>Taking the Bot to the Next Level with AWS Step Functions</h3>
<p class="noindent">With the communication pathways created to send messages to Slack, you can take this code to the next level by running it on a schedule and making it do something useful. AWS Step Functions are a powerful way to accomplish this. In the next section, the Slackbot will perform the following actions: scrape Yahoo! sports pages of NBA players, fetch their birthplaces, and then send the information to Slack.</p>
<p class="noindent"><a href="part0018.html#ch7fig2" class="calibre7">Figure 7.2</a> shows the finished step function in action. The first step is to fetch URLs of NBA player profiles, and the second step is use Beautiful Soup to find the birthplaces of each player. When this step function is finished, it will then be triggered to send the results to Slack.</p>
<p class="noindent">AWS Lambda and chalice can be used to coordinate the individual portions of work inside the step function. Lambda (<a href="https://aws.amazon.com/lambda/" class="calibre7">https://aws.amazon.com/lambda/</a>) allows a user to run functions in AWS, and chalice (<a href="http://chalice.readthedocs.io/en/latest/" class="calibre7">http://chalice.readthedocs.io/en/latest/</a>) is a framework for building serverless applications in Python. Some prerequisites to get started are as follows.</p>
<ul class="calibre13">
<li class="calibre14"><p class="bullet">The user must have an AWS account.</p></li>
<li class="calibre14"><p class="bullet">The user needs API credentials.</p></li>
<li class="calibre14"><p class="bullet">The Lambda role (that chalice creates) must have a policy associated with privileges necessary to call appropriate AWS services, such as S3.</p></li>
</ul>
<h3 id="ch07lev4" class="calibre12">Getting IAM Credentials Set Up</h3>
<p class="noindent">For detailed instructions on setting up AWS credentials, go to <a href="http://boto3.readthedocs.io/en/latest/guide/configuration.html" class="calibre7">http://boto3.readthedocs.io/en/latest/guide/configuration.html</a>. For details about exporting AWS variables on Windows and Linux, visit <a href="https://docs.aws.amazon.com/amazonswf/latest/awsrbflowguide/set-up-creds.html" class="calibre7">https://docs.aws.amazon.com/amazonswf/latest/awsrbflowguide/set-up-creds.html</a>. There are many ways configure credentials, but for users of virtualenv, one trick is to put your AWS credentials into your local virtualenv inside /bin/activate.</p>
<p class="pre">#Add AWS Keys<br class="calibre9"/>
AWS_DEFAULT_REGION=us-east-1<br class="calibre9"/>
AWS_ACCESS_KEY_ID=xxxxxxxx<br class="calibre9"/>
AWS_SESSION_TOKEN=xxxxxxxx<br class="calibre9"/>
<br class="calibre9"/>
#export Keys<br class="calibre9"/>
export AWS_DEFAULT_REGION<br class="calibre9"/>
export AWS_ACCESS_KEY_ID<br class="calibre9"/>
export AWS_DEFAULT_REGION</p>
<h4 id="ch07lev4sub1" class="calibre16">Working with Chalice</h4>
<p class="noindent">Chalice has a command-line tool that has many subcommands, as shown.</p>
<p class="codelink"><a id="p137pro01" href="part0036_split_003.html#p137pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">Usage: chalice [OPTIONS] COMMAND [ARGS]...<br class="calibre9"/>
<br class="calibre9"/>
Options:<br class="calibre9"/>
  --version             Show the version and exit.<br class="calibre9"/>
  --project-dir TEXT    The project directory.  Defaults to CWD<br class="calibre9"/>
  --debug / --no-debug  Print debug logs to stderr.<br class="calibre9"/>
  --help                Show this message and exit.<br class="calibre9"/>
<br class="calibre9"/>
Commands:<br class="calibre9"/>
  delete<br class="calibre9"/>
  deploy<br class="calibre9"/>
  gen-policy<br class="calibre9"/>
  generate-pipeline  Generate a cloudformation template for a...<br class="calibre9"/>
  generate-sdk<br class="calibre9"/>
  local<br class="calibre9"/>
  logs<br class="calibre9"/>
  new-project<br class="calibre9"/>
  package<br class="calibre9"/>
  url</p>
<p class="noindent"><span epub:type="pagebreak" id="page_137"></span>Inside of the skeleton app.py file, code will be replaced with several Lambda functions. One of the nice things about AWS Chalice is that it not only handles creating web services, but it allows for the creation of “standalone” Lambda functions. This functionality will allow for the creation of multiple Lambda functions that can be associated with the step function and plugged together like LEGO blocks.</p>
<p class="noindent">For example, to create timed Lambda that does something, it is straightforward.</p>
<p class="codelink"><a id="p137pro02" href="part0036_split_004.html#p137pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">@app.schedule(Rate(1, unit=Rate.MINUTES))<br class="calibre9"/>
def every_minute(event):<br class="calibre9"/>
    """Scheduled event that runs every minute"""<br class="calibre9"/>
<br class="calibre9"/>
    #send message to slackbot here<br class="calibre9"/>
    </p>
<p class="noindent">To wire up the web-scraping bot, you need to create a few functions. At the top of the file, some imports are created along with a few variables.</p>
<p class="codelink"><a id="p137pro03" href="part0036_split_005.html#p137pro03a" class="calibre7">Click here to view code image</a></p>
<p class="pre">import logging<br class="calibre9"/>
import csv<br class="calibre9"/>
from io import StringIO<br class="calibre9"/>
<br class="calibre9"/>
import boto3<br class="calibre9"/>
from bs4 import BeautifulSoup<br class="calibre9"/>
import requests<br class="calibre9"/>
from chalice import (Chalice, Rate)<br class="calibre9"/>
<br class="calibre9"/>
APP_NAME = 'scrape-yahoo'<br class="calibre9"/>
app = Chalice(app_name=APP_NAME)<br class="calibre9"/>
app.log.setLevel(logging.DEBUG)</p>
<p class="noindent">It might be useful for the bot to store some data in S3. This function uses Boto to store the results into a CSV file.</p>
<p class="codelink"><a id="p138pro01" href="part0036_split_006.html#p138pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">def create_s3_file(data, name="birthplaces.csv"):<br class="calibre9"/>
<br class="calibre9"/>
    csv_buffer = StringIO()<br class="calibre9"/>
    app.log.info(f"Creating file with {data} for name")<br class="calibre9"/>
    writer = csv.writer(csv_buffer)<br class="calibre9"/>
    for key, value in data.items():<br class="calibre9"/>
        writer.writerow([key,value])<br class="calibre9"/>
    s3 = boto3.resource('s3')<br class="calibre9"/>
    res = s3.Bucket('aiwebscraping').\<br class="calibre9"/>
        put_object(Key=name, Body=csv_buffer.getvalue())<br class="calibre9"/>
    return res</p>
<p class="noindent"><span epub:type="pagebreak" id="page_138"></span>The Fetch page function uses Beautiful Soup (<a href="https://www.crummy.com/software/BeautifulSoup" class="calibre7">https://www.crummy.com/software/BeautifulSoup</a>) to parse the NBA stats URL and return a <code class="calibre11">soup</code> object.</p>
<p class="codelink"><a id="p138pro02" href="part0036_split_007.html#p138pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">def fetch_page(url="https://sports.yahoo.com/nba/stats/"):<br class="calibre9"/>
    """Fetchs Yahoo URL"""<br class="calibre9"/>
<br class="calibre9"/>
    #Download the page and convert it into a beautiful soup object<br class="calibre9"/>
    app.log.info(f"Fetching urls from {url}")<br class="calibre9"/>
    res = requests.get(url)<br class="calibre9"/>
    soup = BeautifulSoup(res.content, 'html.parser')<br class="calibre9"/>
    return soup</p>
<p class="noindent">The <code class="calibre11">get_player_links</code> function and the <code class="calibre11">fetch_player_urls</code> function grab links to player profile URLs.</p>
<p class="codelink"><a id="p138pro03" href="part0036_split_008.html#p138pro03a" class="calibre7">Click here to view code image</a></p>
<p class="pre"><br class="calibre9"/>
def get_player_links(soup):<br class="calibre9"/>
    """Gets links from player urls<br class="calibre9"/>
        <br class="calibre9"/>
   Finds urls in page via the 'a' tag and<br class="calibre9"/>
filter for nba/players in urls<br class="calibre9"/>
    """<br class="calibre9"/>
    <br class="calibre9"/>
    nba_player_urls = []<br class="calibre9"/>
    for link in soup.find_all('a'):<br class="calibre9"/>
        link_url = link.get('href')<br class="calibre9"/>
        #Discard "None"<br class="calibre9"/>
        if link_url:<br class="calibre9"/>
            if "nba/players" in link_url:<br class="calibre9"/>
                print(link_url)<br class="calibre9"/>
                nba_player_urls.append(link_url)<br class="calibre9"/>
    return nba_player_urls<br class="calibre9"/>
<br class="calibre9"/>
<br class="calibre9"/>
def fetch_player_urls():<br class="calibre9"/>
    """Returns player urls"""<br class="calibre9"/>
<br class="calibre9"/>
    soup = fetch_page()<br class="calibre9"/>
    urls = get_player_links(soup)<br class="calibre9"/>
    return urls</p>
<p class="noindent"><span epub:type="pagebreak" id="page_139"></span>Next, birthplaces are extracted from the URLs in the <code class="calibre11">find_birthplaces</code> function.</p>
<p class="codelink"><a id="p139pro01" href="part0036_split_009.html#p139pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">def find_birthplaces(urls):<br class="calibre9"/>
    """Get the Birthplaces From Yahoo Profile NBA Pages"""<br class="calibre9"/>
<br class="calibre9"/>
    birthplaces = {}<br class="calibre9"/>
    for url in urls:<br class="calibre9"/>
        profile = requests.get(url)<br class="calibre9"/>
        profile_url = BeautifulSoup(profile.content, 'html.parser')<br class="calibre9"/>
        lines = profile_url.text<br class="calibre9"/>
        res2 = lines.split(",")<br class="calibre9"/>
        key_line = []<br class="calibre9"/>
        for line in res2:<br class="calibre9"/>
            if "Birth" in line:<br class="calibre9"/>
                #print(line)<br class="calibre9"/>
                key_line.append(line)<br class="calibre9"/>
        try:<br class="calibre9"/>
            birth_place = key_line[0].split(":")[-1].strip()<br class="calibre9"/>
<span epub:type="pagebreak" id="page_140"></span>
            app.log.info(f"birth_place: {birth_place}")<br class="calibre9"/>
        except IndexError:<br class="calibre9"/>
            app.log.info(f"skipping {url}")<br class="calibre9"/>
            continue<br class="calibre9"/>
        birthplaces[url] = birth_place<br class="calibre9"/>
        app.log.info(birth_place)<br class="calibre9"/>
    return birthplaces</p>
<p class="noindent">The next section gets into the chalice functions. Note that chalice requires that a default route be created.</p>
<p class="codelink"><a id="p139pro02" href="part0036_split_010.html#p139pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">#These can be called via HTTP Requests<br class="calibre9"/>
@app.route('/')<br class="calibre9"/>
def index():<br class="calibre9"/>
    """Root URL"""<br class="calibre9"/>
<br class="calibre9"/>
    app.log.info(f"/ Route: for {APP_NAME}")<br class="calibre9"/>
    return {'app_name': APP_NAME}</p>
<p class="noindent">The next Lambda is a route that wires up an HTTP URL with the function written earlier.</p>
<p class="codelink"><a id="p139pro02z" href="part0036_split_011.html#p139pro02zz" class="calibre7">Click here to view code image</a></p>
<p class="pre">@app.route('/player_urls')<br class="calibre9"/>
def player_urls():<br class="calibre9"/>
    """Fetches player urls"""<br class="calibre9"/>
<br class="calibre9"/>
    app.log.info(f"/player_urls Route: for {APP_NAME}")<br class="calibre9"/>
    urls = fetch_player_urls()<br class="calibre9"/>
    return {"nba_player_urls": urls}</p>
<p class="noindent">The following Lambdas are “standalone” Lambdas, which can be called within the step function.</p>
<p class="codelink"><a id="p139pro03" href="part0036_split_012.html#p139pro03a" class="calibre7">Click here to view code image</a></p>
<p class="pre">#This a standalone lambda<br class="calibre9"/>
@app.lambda_function()<br class="calibre9"/>
def return_player_urls(event, context):<br class="calibre9"/>
    """Standalone lambda that returns player urls"""<br class="calibre9"/>
<br class="calibre9"/>
    app.log.info(f"standalone lambda 'return_players_urls'\<br class="calibre9"/>
 {APP_NAME} with {event} and {context}")<br class="calibre9"/>
    urls = fetch_player_urls()<br class="calibre9"/>
    return {"urls": urls}<br class="calibre9"/>
<br class="calibre9"/>
#This a standalone lambda<br class="calibre9"/>
@app.lambda_function()<br class="calibre9"/>
def birthplace_from_urls(event, context):<br class="calibre9"/>
    """Finds birthplaces"""<br class="calibre9"/>
<br class="calibre9"/>
    app.log.info(f"standalone lambda 'birthplace_from_urls'\<br class="calibre9"/>
 {APP_NAME} with {event} and {context}")<br class="calibre9"/>
    payload = event["urls"]<br class="calibre9"/>
    birthplaces = find_birthplaces(payload)<br class="calibre9"/>
    return birthplaces<br class="calibre9"/>
<br class="calibre9"/>
#This a standalone lambda<br class="calibre9"/>
@app.lambda_function()<br class="calibre9"/>
def create_s3_file_from_json(event, context):<br class="calibre9"/>
    """Create an S3 file from json data"""<br class="calibre9"/>
<br class="calibre9"/>
    app.log.info(f"Creating s3 file with event data {event}\<br class="calibre9"/>
 and context {context}")<br class="calibre9"/>
    print(type(event))<br class="calibre9"/>
    res = create_s3_file(data=event)<br class="calibre9"/>
    app.log.info(f"response of putting file: {res}")<br class="calibre9"/>
    return True</p>
<p class="noindent">Running the chalice app locally shows the following output.</p>
<p class="codelink"><a id="p140pro01" href="part0036_split_013.html#p140pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">→  scrape-yahoo git:(master) ✗ chalice local<br class="calibre9"/>
Serving on 127.0.0.1:8000<br class="calibre9"/>
scrape-yahoo - INFO - / Route: for scrape-yahoo<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:42] "GET / HTTP/1.1" 200 -<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:42] "GET /favicon.ico"<br class="calibre9"/>
scrape-yahoo - INFO - / Route: for scrape-yahoo<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:45] "GET / HTTP/1.1" 200 -<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:45] "GET /favicon.ico"<br class="calibre9"/>
scrape-yahoo - INFO - /player_urls Route: for scrape-yahoo<br class="calibre9"/>
scrape-yahoo - INFO - https://sports.yahoo.com/nba/stats/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4563/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5185/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/3704/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5012/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4612/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5015/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4497/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4720/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/3818/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5432/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5471/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4244/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5464/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5294/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5336/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4390/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4563/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/3704/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/5600/<br class="calibre9"/>
https://sports.yahoo.com/nba/players/4624/<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:53] "GET /player_urls"<br class="calibre9"/>
127.0.0.1 - - [12/Dec/2017 03:25:53] "GET /favicon.ico"</p>
<p class="noindent"><span epub:type="pagebreak" id="page_141"></span>To deploy the app, run <code class="calibre11">chalice deploy</code>.</p>
<p class="codelink"><a id="p141pro01" href="part0036_split_014.html#p141pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">→  scrape-yahoo git:(master) ✗ chalice deploy<br class="calibre9"/>
Creating role: scrape-yahoo-dev<br class="calibre9"/>
Creating deployment package.<br class="calibre9"/>
Creating lambda function: scrape-yahoo-dev<br class="calibre9"/>
Initiating first time deployment.<br class="calibre9"/>
Deploying to API Gateway stage: api<br class="calibre9"/>
https://bt98uzs1cc.execute-api.us-east-1.amazonaws.com/api/</p>
<p class="noindent">Using the HTTP CLI (<a href="https://github.com/jakubroztocil/httpie" class="calibre7">https://github.com/jakubroztocil/httpie</a>), the HTTP route is now called from AWS to retrieve the links available at /api/player_urls.</p>
<p class="codelink"><a id="p141pro02" href="part0036_split_015.html#p141pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">→  scrape-yahoo git:(master) ✗ http \<br class="calibre9"/>
https://&lt;a lambda route&gt;.amazonaws.com/api/player_urls<br class="calibre9"/>
HTTP/1.1 200 OK<br class="calibre9"/>
Connection: keep-alive<br class="calibre9"/>
Content-Length: 941<br class="calibre9"/>
Content-Type: application/json<br class="calibre9"/>
Date: Tue, 12 Dec 2017 11:48:41 GMT<br class="calibre9"/>
Via: 1.1 ba90f9bd20de9ac04075a8309c165ab1.cloudfront.net (CloudFront)<br class="calibre9"/>
X-Amz-Cf-Id: ViZswjo4UeHYwrc9e-5vMVTDhV_Ic0dhVIG0BrDdtYqd5KWcAuZKKQ==<br class="calibre9"/>
X-Amzn-Trace-Id: sampled=0;root=1-5a2fc217-07cc12d50a4d38a59a688f5c<br class="calibre9"/>
X-Cache: Miss from cloudfront<br class="calibre9"/>
x-amzn-RequestId: 64f24fcd-df32-11e7-a81a-2b511652b4f6<br class="calibre9"/>
<br class="calibre9"/>
{<br class="calibre9"/>
    "nba_player_urls": [<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4563/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5185/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/3704/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5012/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4612/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5015/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4497/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4720/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/3818/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5432/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5471/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4244/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5464/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5294/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5336/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4390/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4563/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/3704/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/5600/",<br class="calibre9"/>
        "https://sports.yahoo.com/nba/players/4624/"<br class="calibre9"/>
    ]<br class="calibre9"/>
}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_142"></span>Another convenient way to interact with the Lambda functions is to call it directly via click and the Python Boto library. A new command-line tool can be created called wscli.py (short for  “web-scraping command-line interface”). The first part of the code sets up logging and imports the libraries.</p>
<p class="codelink"><a id="p142pro01" href="part0036_split_016.html#p142pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">#!/usr/bin/env python<br class="calibre9"/>
<br class="calibre9"/>
import logging<br class="calibre9"/>
import json<br class="calibre9"/>
<br class="calibre9"/>
import boto3<br class="calibre9"/>
import click<br class="calibre9"/>
from pythonjsonlogger import jsonlogger<br class="calibre9"/>
<br class="calibre9"/>
#intialize logging<br class="calibre9"/>
log = logging.getLogger(__name__)<br class="calibre9"/>
log.setLevel(logging.INFO)<br class="calibre9"/>
LOGHANDLER = logging.StreamHandler()<br class="calibre9"/>
FORMMATTER = jsonlogger.JsonFormatter()<br class="calibre9"/>
LOGHANDLER.setFormatter(FORMMATTER)<br class="calibre9"/>
log.addHandler(LOGHANDLER)</p>
<p class="noindent">Next, the three functions are used to connect to the Lambda function via <code class="calibre11">invoke_lambda</code>.</p>
<p class="codelink"><a id="p142pro02" href="part0036_split_017.html#p142pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">### Lambda Boto API Calls<br class="calibre9"/>
def lambda_connection(region_name="us-east-1"):<br class="calibre9"/>
    """Create Lambda Connection"""<br class="calibre9"/>
<br class="calibre9"/>
    lambda_conn = boto3.client("lambda", region_name=region_name)<br class="calibre9"/>
    extra_msg = {"region_name": region_name, "aws_service": "lambda"}<br class="calibre9"/>
    log.info("instantiate lambda client", extra=extra_msg)    <br class="calibre9"/>
    return lambda_conn<br class="calibre9"/>
<br class="calibre9"/>
def parse_lambda_result(response):<br class="calibre9"/>
    """Gets the results from a boto json response"""<br class="calibre9"/>
    <br class="calibre9"/>
    body = response['Payload']<br class="calibre9"/>
    json_result = body.read()<br class="calibre9"/>
    lambda_return_value = json.loads(json_result)<br class="calibre9"/>
    return lambda_return_value<br class="calibre9"/>
<br class="calibre9"/>
def invoke_lambda(func_name, lambda_conn, payload=None,<br class="calibre9"/>
                    invocation_type="RequestResponse"):<br class="calibre9"/>
    """Calls a lambda function"""<br class="calibre9"/>
<br class="calibre9"/>
<br class="calibre9"/>
    extra_msg = {"function_name": func_name, "aws_service": "lambda",<br class="calibre9"/>
            "payload":payload}<br class="calibre9"/>
    log.info("Calling lambda function", extra=extra_msg)<br class="calibre9"/>
    if not payload:<br class="calibre9"/>
        payload = json.dumps({"payload":"None"})<br class="calibre9"/>
    <br class="calibre9"/>
    response = lambda_conn.invoke(FunctionName=func_name,<br class="calibre9"/>
                    InvocationType=invocation_type,<br class="calibre9"/>
                    Payload=payload<br class="calibre9"/>
    )<br class="calibre9"/>
    log.info(response, extra=extra_msg)<br class="calibre9"/>
    lambda_return_value = parse_lambda_result(response)<br class="calibre9"/>
    return lambda_return_value</p>
<p class="noindent"><span epub:type="pagebreak" id="page_143"></span>This Lambda invoke function is then wrapped up by the click command-line tool framework. Note, the <code class="calibre11">–func</code> option is defaulted to use the Lambda function deployed earlier.</p>
<p class="codelink"><a id="p143pro01" href="part0036_split_018.html#p143pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">@click.group()<br class="calibre9"/>
@click.version_option("1.0")<br class="calibre9"/>
def cli():<br class="calibre9"/>
    """Commandline Utility to Assist in Web Scraping"""<br class="calibre9"/>
<br class="calibre9"/>
@cli.command("lambda")<br class="calibre9"/>
@click.option("--func",<br class="calibre9"/>
        default="scrape-yahoo-dev-return_player_urls",<br class="calibre9"/>
        help="name of execution")<br class="calibre9"/>
@click.option("--payload", default='{"cli":"invoke"}',<br class="calibre9"/>
        help="name of payload")<br class="calibre9"/>
def call_lambda(func, payload):<br class="calibre9"/>
    """invokes lambda function<br class="calibre9"/>
    <br class="calibre9"/>
    ./wscli.py lambda<br class="calibre9"/>
    """<br class="calibre9"/>
    click.echo(click.style("Lambda Function invoked from cli:",<br class="calibre9"/>
         bg='blue', fg='white'))<br class="calibre9"/>
    conn = lambda_connection()<br class="calibre9"/>
    lambda_return_value = invoke_lambda(func_name=func,<br class="calibre9"/>
        lambda_conn=conn,<br class="calibre9"/>
        payload=payload)<br class="calibre9"/>
    formatted_json = json.dumps(lambda_return_value,<br class="calibre9"/>
          sort_keys=True, indent=4)<br class="calibre9"/>
    click.echo(click.style(<br class="calibre9"/>
        "Lambda Return Value Below:", bg='blue', fg='white'))<br class="calibre9"/>
    click.echo(click.style(formatted_json,fg="red"))<br class="calibre9"/>
<br class="calibre9"/>
if __name__ == "__main__":<br class="calibre9"/>
    cli()</p>
<p class="noindent"><span epub:type="pagebreak" id="page_144"></span>The output of the command-line tool shows the same net output as calling the HTTP interface.</p>
<p class="codelink"><a id="p144pro01" href="part0036_split_019.html#p144pro01a" class="calibre7">Click here to view code image</a></p>
<p class="pre">→  ✗ ./wscli.py lambda \<br class="calibre9"/>
--func=scrape-yahoo-dev-birthplace_from_urls\<br class="calibre9"/>
--payload '{"url":["https://sports.yahoo.com/nba/players/4624/",\<br class="calibre9"/>
"https://sports.yahoo.com/nba/players/5185/"]}'<br class="calibre9"/>
Lambda Function invoked from cli:<br class="calibre9"/>
{"message": "instantiate lambda client",<br class="calibre9"/>
"region_name": "us-east-1", "aws_service": "lambda"}<br class="calibre9"/>
{"message": "Calling lambda function",<br class="calibre9"/>
"function_name": "scrape-yahoo-dev-birthplace_from_urls",<br class="calibre9"/>
 "aws_service": "lambda", "payload":<br class="calibre9"/>
"{\"url\":[\"https://sports.yahoo.com/nba/players/4624/\",<br class="calibre9"/>
 \"https://sports.yahoo.com/nba/players/5185/\"]}"}<br class="calibre9"/>
{"message": null, "ResponseMetadata":<br class="calibre9"/>
{"RequestId": "a6049115-df59-11e7-935d-bb1de9c0649d",<br class="calibre9"/>
"HTTPStatusCode": 200, "HTTPHeaders":<br class="calibre9"/>
{"date": "Tue, 12 Dec 2017 16:29:43 GMT", "content-type":<br class="calibre9"/>
 "application/json", "content-length": "118", "connection":<br class="calibre9"/>
"keep-alive", "x-amzn-requestid":<br class="calibre9"/>
"a6049115-df59-11e7-935d-bb1de9c0649d",<br class="calibre9"/>
"x-amzn-remapped-content-length": "0", "x-amz-executed-version":<br class="calibre9"/>
 "$LATEST", "x-amzn-trace-id":<br class="calibre9"/>
"root=1-5a3003f2-2583679b2456022568ed0682;sampled=0"},<br class="calibre9"/>
"RetryAttempts": 0}, "StatusCode": 200,<br class="calibre9"/>
"ExecutedVersion": "$LATEST", "Payload":<br class="calibre9"/>
"&lt;botocore.response.StreamingBody object at 0x10ee37dd8&gt;",<br class="calibre9"/>
"function_name": "scrape-yahoo-dev-birthplace_from_urls",<br class="calibre9"/>
 "aws_service": "lambda", "payload":<br class="calibre9"/>
"{\"url\":[\"https://sports.yahoo.com/nba/players/4624/\",<br class="calibre9"/>
\"https://sports.yahoo.com/nba/players/5185/\"]}"}<br class="calibre9"/>
Lambda Return Value Below:<br class="calibre9"/>
{<br class="calibre9"/>
    "https://sports.yahoo.com/nba/players/4624/": "Indianapolis",<br class="calibre9"/>
    "https://sports.yahoo.com/nba/players/5185/": "Athens"<br class="calibre9"/>
}</p>
<h3 id="ch07lev5" class="calibre12">Building Out the Step Function</h3>
<p class="noindent">The final step to get the step function wired up, as described in the documentation from AWS (<a href="https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-creating-activity-state-machine.html" class="calibre7">https://docs.aws.amazon.com/step-functions/latest/dg/tutorial-creating-activity-state-machine.html</a>), is to create the state machine structure in JavaScript Object Notation (JSON) using the web UI. The following code shows how this pipeline goes from the initial Lambda functions, which scrape Yahoo!, to storing the data in S3, and then finally sending the payload to Slack.</p>
<p class="codelink"><a id="p144pro02" href="part0036_split_020.html#p144pro02a" class="calibre7">Click here to view code image</a></p>
<p class="pre">{<br class="calibre9"/>
    "Comment": "Fetch Player Urls",<br class="calibre9"/>
    "StartAt": "FetchUrls",<br class="calibre9"/>
    "States": {<br class="calibre9"/>
      "FetchUrls": {<br class="calibre9"/>
        "Type": "Task",<br class="calibre9"/>
        "Resource": \<br class="calibre9"/>
"arn:aws:lambda:us-east-1:561744971673:\<br class="calibre9"/>
function:scrape-yahoo-dev-return_player_urls",<br class="calibre9"/>
        "Next": "FetchBirthplaces"<br class="calibre9"/>
      },<br class="calibre9"/>
      "FetchBirthplaces": {<br class="calibre9"/>
        "Type": "Task",<br class="calibre9"/>
        "Resource": \<br class="calibre9"/>
"arn:aws:lambda:us-east-1:561744971673:\<br class="calibre9"/>
function:scrape-yahoo-dev-birthplace_from_urls",<br class="calibre9"/>
        "Next": "WriteToS3"<br class="calibre9"/>
      },<br class="calibre9"/>
       "WriteToS3": {<br class="calibre9"/>
        "Type": "Task",<br class="calibre9"/>
        "Resource": "arn:aws:lambda:us-east-1:\<br class="calibre9"/>
561744971673:function:scrape-yahoo-dev-create_s3_file_from_json",<br class="calibre9"/>
        "Next": "SendToSlack"<br class="calibre9"/>
      },<br class="calibre9"/>
       "SendToSlack": {<br class="calibre9"/>
        "Type": "Task",<br class="calibre9"/>
        "Resource": "arn:aws:lambda:us-east-1:561744971673:\<br class="calibre9"/>
function:send_message",<br class="calibre9"/>
        "Next": "Finish"<br class="calibre9"/>
      },<br class="calibre9"/>
      <br class="calibre9"/>
        "Finish": {<br class="calibre9"/>
        "Type": "Pass",<br class="calibre9"/>
        "Result": "Finished",<br class="calibre9"/>
        "End": true<br class="calibre9"/>
      }<br class="calibre9"/>
    }<br class="calibre9"/>
}</p>
<p class="noindent"><span epub:type="pagebreak" id="page_145"></span>In <a href="part0018.html#ch7fig2" class="calibre7">Figure 7.2</a>, the first portion of the pipeline is shown executing. As shown, one incredibly helpful feature is the ability to see intermediate output in the state machine. Additionally, the monitoring in real time of each portion of the state machine is great for debugging.</p>
<p class="noindent"><a href="part0018.html#ch7fig3" class="calibre7">Figure 7.3</a> shows the complete pipeline with the addition of the steps of writing out to S3 and sending payloads to Slack. The final step would be to decide how to run this scraper: on an interval or perhaps in response to an event.</p>
<div class="figure">
<div class="image1"><span epub:type="pagebreak" id="page_146"></span><a id="ch7fig2" class="calibre7"></a><img src="../images/00041.jpeg" aria-describedby="alt_07fig02" alt="A screenshot of the Slackbot Command Line Tool Initial Pipeline is shown." class="calibre8"/>
<aside class="hidden" id="alt_07fig02" data-AmznRemoved-M8="true" data-AmznRemoved="mobi7">
<p class="calibre21">The screen, start2 displays two dialog boxes. The dialog box on the left show two tabs: Visual Workflow (selected) and Code. The Visual Workflow shows the flow that starts from the top and flows down to the following works: Fetch Urls (success), FetchBirthplaces (success), and Finish (success), and the flow ends. Three options, zoom in, zoom out, and target are shown on the top-right. The dialog box on the right shows, Step Details where the output tab is shown selected. The output below reads the list of URLs.</p>
</aside>
</div>
<p class="fig_caption"><span class="calibre6">Figure 7.2</span> Representation of a Slackbot Command Line Tool Initial Pipeline</p>
</div>
<div class="figure">
<div class="image1"><a id="ch7fig3" class="calibre7"></a><img src="../images/00042.jpeg" aria-describedby="alt_07fig03" alt="A screenshot of the Visual Workflow window is shown." class="calibre8"/>
<aside class="hidden" id="alt_07fig03" data-AmznRemoved-M8="true" data-AmznRemoved="mobi7">
<p class="calibre21">The Visual Workflow shows the flow that starts from the top and flows down to the following works: Fetch Urls, FetchBirthplaces, WriteTo S3, SendToStack, and Finish, and the flow ends. Three options, zoom in, zoom out, and target are shown on the top-right.</p>
</aside>
</div>
<p class="fig_caption"><span class="calibre6">Figure 7.3</span> Representation of a Slackbot Command Line Tool Final Pipeline</p>
</div>
<h3 id="ch07lev6" class="calibre12">Summary</h3>
<p class="noindent">This chapter unleashed many powerful concepts for building AI applications. A Slackbot was created, a web scraper was created, and then they were glued together with serverless services from AWS. More could be added to this initial skeleton—potentially, a Natural Language–processing Lambda that reads web pages and summarizes them or an unsupervised clustering algorithm that clusters new NBA players by arbitrary attributes.</p>
</body></html>
